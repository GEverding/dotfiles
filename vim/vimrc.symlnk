" vim: set foldmarker={,} foldlevel=0 foldmethod=marker:
" Author: Garrett Everding <garrett.everding92@gmail.com>

" Basics {
  set nocp

  filetype off
" }

" Vundle {
  set rtp+=~/.vim/bundle/vundle/
  "set rtp+=~/.vim/bundle/powerline/powerline/bindings/vim
  call vundle#rc()

  " Bundles {
    Bundle 'gmarik/vundle'
    "Bundle 'vimwiki'

    if executable('ag')
      Bundle 'epmatsw/ag.vim'
    endif

    Bundle 'scrooloose/nerdtree'

    Bundle 'tpope/vim-surround'
    Bundle 'tpope/vim-unimpaired'

    "Bundle 'AutoClose'
    Bundle 'kien/ctrlp.vim'
    "Bundle 'matchit.zip'
    Bundle "taglist.vim"
    Bundle 'godlygeek/csapprox'
    "Bundle 'kshenoy/vim-signature.git'
    Bundle 'mbbill/undotree'
    Bundle 'myusuf3/numbers.vim'
    Bundle 'nathanaelkane/vim-indent-guides'

    "Bundle 'Lokaltog/powerline'
    "Bundle 'Lokaltog/vim-easymotion'
    Bundle 'bling/vim-airline'
    Bundle 'jamessan/vim-gnupg'

    Bundle 'scrooloose/syntastic'
    Bundle 'tpope/vim-fugitive'
    Bundle 'airblade/vim-gitgutter'
    Bundle 'scrooloose/nerdcommenter'
    Bundle 'godlygeek/tabular'

    Bundle 'Shougo/vimproc.vim'

    "Bundle 'Shougo/neocomplcache.vim'
    Bundle 'Shougo/neocomplete.vim'
    Bundle 'Shougo/neosnippet.vim'
    Bundle 'Shougo/neosnippet-snippets.git'
    Bundle 'honza/vim-snippets'

    Bundle "majutsushi/tagbar"
    Bundle "29decibel/vim-stringify"

    " Golang {
    "Bundle 'jnwhiteh/vim-golang'
    " }

    " JSON {
    Bundle 'leshill/vim-json'
    " }

    " HTML {
    Bundle 'digitaltoad/vim-jade'
    Bundle 'amirh/HTML-AutoCloseTag'
    Bundle 'othree/html5.vim'
    " }

    " Coffeescript {
    "Bundle 'GEverding/coffeescript.vim'
    Bundle 'kchmck/vim-coffee-script.git'
    " }

    " CSS {
    Bundle 'ChrisYip/Better-CSS-Syntax-for-Vim'
    " }

    " Javascript {
    Bundle 'pangloss/vim-javascript'
    " }

    " Rust {
    "Bundle 'bryanjswift/vim-rust'
    " }

    " Scala {
    Bundle 'derekwyatt/vim-scala'
    Bundle 'derekwyatt/vim-sbt'
    Bundle 'gre/play2vim'
    Bundle 'GEverding/vim-hocon'
    " }

    " PHP {
    "Bundle 'spf13/PIV.git'
    " }

    " Python {
    "Bundle 'python.vim'
    "Bundle 'klen/python-mode'
    "Bundle 'python_match.vim'
    "Bundle 'pythoncomplete'
    " }

    " C/C++ {
    "Bundle 'a.vim'
    " }

    "Ruby {
    "Bundle 'vim-ruby/vim-ruby'
    "Bundle 'tpope/vim-rails'
    " }

    " Haskell {
    "Bundle 'lukerandall/haskellmode-vim'
    Bundle "eagletmt/ghcmod-vim"
    Bundle "eagletmt/neco-ghc"
    Bundle "dag/vim2hs"
    " }

    " SQL {
    "Bundle 'SQLComplete.vim'
    "Bundle 'SQLUtilities'
    " }

    " SQL {
    "Bundle 'SQLComplete.vim'
    "Bundle 'SQLUtilities'
    " }

    " Misc {
    Bundle 'tpope/vim-markdown'
    "Bundle 'spf13/vim-preview'
    " }

  " }

  filetype plugin indent on
  syntax enable

" }

" Colorscheme {

  if has('gui_running')
    set background=dark
    "colorscheme molokai
    colorscheme wombat256v2
    "colorscheme hybrid
  else
    set background=dark
    colorscheme wombat256v2
  endif

" }

" Configuration Options {

  " wrap long lines
  set nowrap
  " turn spelling off
  set nospell

  " Formatting {
    " indent at the same level of the previous line
    set autoindent
    " use indents of 2 spaces
    set shiftwidth=2
    " use multiple of shiftwidth when indenting with '<' and '>'
    set shiftround
    " tabs are spaces, not tabs
    set expandtab
    " an indentation every four columns

    " let backspace delete indent
    set softtabstop=2

    " Display Numbers
    set number
  " }

  " Searching {

    " highlight search terms
    set hlsearch
    " show search matches as you type
    set incsearch
    " case insensitive search
    set ignorecase
    " case sensitive when uc presentet history=1000
    set smartcase

  " }

  " Hides Buffers instead of Closing them
  set hidden
  set ruler
  set history=1000
  set cursorline
  " better unix / windows compatibility
  set mouse=a
  " abbrev. of messages (avoids 'hit enter')
  set shortmess+=filmnrxoOtT
  " better unix / windows compatibility
  set viewoptions=folds,options,cursor,unix,slash

  " allow for cursor beyond last character"
  set virtualedit=onemore
  set foldenable
  set colorcolumn=81
  set tags=tags,$HOME/software/scala-2.10.3/akka_tags,$HOME/software/scala-2.10.3/scala_tags;
  set laststatus=2 " Always display the statusline in all windows
  set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
  "set showmode
  " backspace for dummies
  set backspace=indent,eol,start
  " backspace and cursor keys wrap to
  set whichwrap=b,s,h,l,<,>,[,]
  " lines to scroll when cursor leaves screen
  set scrolljump=5
  " minimum lines to keep above and below cursor
  set scrolloff=5

  set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.class

  set nu

  set backup
  set backupdir=~/.vimbackup
  if has('persistent_undo')
    set undofile                " Save undo's after file closes
    set undodir=$HOME/.vimundo  " where to save undo histories
    set undolevels=1000         " How many undos
    set undoreload=10000        " number of lines to save for undo
  endif
  set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

" }

" Autocommands {

  au BufEnter,BufNew,BufRead,BufReadPre *.do set ft=sh
  au BufNew,BufRead,BufEnter,BufReadPre *.js set filetype=javascript
  au BufEnter,BufNew,BufRead,BufReadPre *.coffee set filetype=coffee
  au BufEnter,BufNew,BufRead,BufReadPre *.jade set filetype=jade
  "au BufEnter,BufNew,BufRead *.json set ft=json
  au BufEnter,BufNew,BufRead,BufReadPre *.less set filetype=less
  au BufEnter,BufNew,BufRead,BufReadPre *.md set filetype=markdown
  au BufEnter,BufNew,BufRead *.scala set ft=scala
  au BufEnter,BufNew,BufRead *.rs set ft=rust
  au BufEnter,BufNew,BufRead,BufReadPre *.go set filetype=go
  au BufEnter,BufNew,BufRead,BufReadPre *.md set filetype=markdown
  au BufEnter,BufNew,BufRead,BufReadPre *.md set filetype=markdown
  " play framework
  au BufRead,BufNewFile *.scala.html set filetype=html syntax=play2-html
  au BufRead,BufNewFile */conf/\(*\|\)routes set filetype=play2-routes
  "au BufRead,BufNewFile */conf/*.conf setf play2-conf
  au BufRead,BufNewFile plugins.sbt set filetype=scala
  au BufRead,BufNewFile */conf/*.conf set ft=hocon

  "au BufNewFile,BufRead,BufEnter *.py set tabstop=4 softtabstop=4 shiftwidth=4

  "au BufNewFile,BufRead,BufEnter *.py set tabstop=4 softtabstop=4 shiftwidth=4

  " format go code
  au FileType go autocmd BufWritePre <buffer> Fmt

  au Filetype md,markdown set spell wrap

  " Remove White space and ^M
  autocmd FileType c,cpp,java,go,php,javascript,python,twig,xml,yml autocmd BufWritePre <buffer> call StripTrailingWhitespace()

  " Open to last position
  au BufWinLeave *.* silent!  mkview
  au BufWinEnter *.* silent! loadview

" }

" Re-Mappings {
  inoremap jj <ESC>
  let mapleader= ','

  " Better Movement
  map <C-J> <C-W>j<C-W>
  map <C-K> <C-W>k<C-W>
  map <C-L> <C-W>l<C-W>
  map <C-H> <C-W>h<C-W>

  " Tab Switching
  map <A-1> 1gt
  map <A-2> 2gt
  map <A-3> 3gt
  map <A-4> 4gt

  " Clear Search
  nmap <silent> <leader>/ :nohlsearch<CR>

  " screen line scroll
  nnoremap <silent> j gj
  nnoremap <silent> k gk

  " reselect visual block after indent
  vnoremap < <gv
  vnoremap > >gv

  " Remove Whitepace
  nnoremap <silent> <F5> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>

  "Switch number mode
  nnoremap <F3> :NumbersToggle<CR>

  " Set panes to same width
  map <Leader>= <C-w>=

  " For when I forget to sudo
  cmap w!! w !sudo tee % >/dev/null

  " Quickly edit/reload the vimrc file
  nmap <silent> <leader>ev :e ~/.vimrc<CR>
  nmap <silent> <leader>sv :so ~/.vimrc <CR>

  cmap c! call RCmd("")<Left><Left>
  cmap <Leader>c call RCmd("./create_component ")<Left><Left>
  map <F4> :call RCmd("make")<CR>
  map <F6> :call RCmd("make tests")<CR>
  "map <F6> :call RCmd("npm test")<CR>

  cmap Agc Ag -G coffee$ ""<Left>
  cmap Agh Ag -G hs$ ""<Left>
  cmap Agj Ag -G jade$ ""<Left>
  cmap Agl Ag -G less$ ""<Left>
  cmap Ags Ag -G scala$ ""<Left>
  nmap ,sf :AgForFiletype 

  nmap <silent> ,cr :lcd <c-r>=FindGitDirOrRoot()<cr><cr>

  " Stringify() {
    map <leader>g :call Stringify()<CR>
  " }
" }

" Color Configurations {
  syn match myTodo contained   "\<\(TODO\|FIXME\|HACK\|NOTE\|WTF\):"
  hi def link myTodo Todo
" }

" Plugins {

  " OmniComplete {
    "if has("autocmd") && exists("+omnifunc")
     "autocmd Filetype *
       "\if &omnifunc == "" |
       "\setlocal omnifunc=syntaxcomplete#Complete |
       "\endif
    "endif

    hi Pmenu  guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
    hi PmenuSbar  guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
    hi PmenuThumb  guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

    """ some convenient mappings
    "inoremap <expr> <Esc>      pumvisible() ? "\<C-e>" : "\<Esc>"
    "inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
    "inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
    "inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
    "inoremap <expr> <C-d>      pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
    "inoremap <expr> <C-u>      pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

    """ automatically open and close the popup menu / preview window
    "au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
    "set completeopt=menu,preview,longest

  " }

  " NeoComplCache {

    "Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
    let g:neocomplete#force_overwrite_completefunc = 1

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
            \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
      return neocomplete#close_popup() . "\<CR>"
      " For no inserting <CR> key.
      "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    " Close popup by <Space>.

    "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

    " For cursor moving in insert mode(Not recommended)
    "inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
    "inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
    "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
    "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
    " Or set this.
    "let g:neocomplete#enable_cursor_hold_i = 1
    " Or set this.
    "let g:neocomplete#enable_insert_char_pre = 1

    " AutoComplPop like behavior.
    "let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif
    "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
  " }

  " Neosnippet {

    " Plugin key-mappings.
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)
    xmap <C-k>     <Plug>(neosnippet_expand_target)


    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
      \ "\<Plug>(neosnippet_expand_or_jump)"
      \: pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
      \ "\<Plug>(neosnippet_expand_or_jump)"
      \: "\<TAB>"

    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif

    " Enable snipMate compatibility feature.
    let g:neosnippet#enable_snipmate_compatibility = 1

    " Tell Neosnippet about the other snippets
    let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets/'

  " }

  " Indent Guides {
    let g:indent_guides_auto_colors = 0
    set ts=2 sw=2 et
    let g:indent_guides_start_level = 2
    let g:indent_guides_guide_size = 1
    let g:indent_guides_enable_on_vim_startup = 0
    let g:indent_guides_enable_on_vim_startup = 1
  "}

  " UndoTree {
    nnoremap <Leader>u :UndotreeToggle<CR>
    if has ('persistent_mode')
      set undofile
      set undolevel=1000
      set undoeload=10000
    endif

  " }

  " NerdTree {

     map <C-e> :NERDTreeToggle<CR>
     map <leader>e :NERDTREEFind<CR>

     "let NERDTreeShowBookmakrs=1
     let NERDTreeIgnore=['\.git', '\.redo$', '\~$', '\.swp$', '\.hg', '\.class']
     "let NERDTreeChDirMode=1
     "let NERDTreeShowBookmakrs=1
     "let NERDTreeMouseMode=1
     let NERDTreeQuitOnOpen=1
     "let NEDTreeMouseMode=2
     "let NERDTreeShowHidden=1
     "let NERDTreeKeepTreeInNewTab=1
     "let g:nerdtree_tabs_open_on_gui_startup=0
   " }

    " Tabularize {

      nmap <Leader>a= :Tabularize /=<CR>
      vmap <Leader>a= :Tabularize /=<CR>
      nmap <Leader>a: :Tabularize /:\zs<CR>
      vmap <Leader>a: :Tabularize /:\zs<CR>

    " }

   " Powerline {

     " setup powerline
     ""source ~/.local/lib/python3.2/site-packages/powerline/bindings/vim/plugin/powerline.vim
     "python3 from powerline.vim import setup as powerline_setup
     "python3 powerline_setup()
     "python3 del powerline_setup

     "let g:Powerline_symbols='fancy'

     if has('statusline')
       " Broken down into easily includeable segments
       set statusline=%<%f\    " Filename
       set statusline+=%*
       set statusline+=%{fugitive#statusline()} "  Git Hotness
       set statusline+=\ [%{&ff}/%Y]            " filetype
       set statusline+=\ [%{getcwd()}]          " current dir
       set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav
     endif

   " }

   " Syntasic {
      let g:syntastic_error_symbol='✗>'
      let g:syntastic_style_error_symbol='✗>'
      let g:syntastic_warning_symbol='⚠>'
      let g:syntastic_style_warning_symbol='⚠>'

      let g:syntastic_check_on_open = 0
      let g:syntastic_javascript_checkers = ['jshint']
      let g:syntastic_jshint_exec="/Users/geverding/.local/bin/jshint"
      let g:syntastic_scala_checkers = ['']
      let g:syntastic_html_checkers = ['']
      let g:syntastic_haskell_checkers = ['ghc_mod', 'hlint']
      "let g:syntastic_scalac_exec="/Users/geverding/software/scala-2.10.3/bin/scalac"
      let g:syntastic_c_check_header = 1
      let g:syntastic_c_compiler = 'clang'
      let g:syntastic_fsc_exec = '/Users/geverding/software/scala-2.10.3/bin/fsc'

   " }

   " VimWiki {
     "let g:vimwiki_list = [{'path': '~/.vimwiki',
                          "\ 'syntax': 'markdown', 'ext': '.md'}]
   " }

    " Colorcolums {
        "hi ColorColumn guibg=#2d2d2d ctermbg=246
    " }

    " ctrlp {
      let g:ctrlp_cmd = "CtrlP"
      let g:ctrlp_working_path_mode = 'r'
      let g:ctrlp_root_marker = [".root"]
      let g:ctrlp_extensions = ['tag']

      let g:ctrlp_custom_ignore = '\v%(/\.%(git|hg|svn)|\.%(class|o|png|jpg|jpeg|bmp|tar|jar|tgz|deb|zip)$|/target/%(quickfix|resolution-cache|streams|test-reports)|/target/scala-2.10/%(classes|test-classes|sbt-0.13|cache|test-reports)|/project/target|/project/project)'
      "let g:ctrlp_custom_ignore = {
        "\ 'dir': '\node_modules$\|\.DS_Store$\|\.git$\|\.hg$\|\.svn$\|\.redo$\',
        "\ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$|\.dir$|\.class$\' }


      "let g:ctrlp_user_command = {
      "    \ 'types': {
      "        \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
      "        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      "    \ },
      "    \ 'fallback': 'find %s -type f'
      "\ }
    " }

    " airline {
      let g:airline_theme='badwolf'

      let g:airline_powerline_fonts=1
      let g:airline_left_sep = ''
      let g:airline_right_sep = ''
      let g:airline_branch_prefix = ' '
      let g:airline_readonly_symbol = ''
      let g:airline_linecolumn_prefix = ' '
    " }

    " taglist.vim {

      " Taglist Scala support
      let tlist_scala_settings = 'scala;' .
                              \ 'p:packages;' .
                              \ 'a:abstract classes;' .
                              \ 'c:classes;' .
                              \ 'm:case classes;' .
                              \ 'o:objects;' .
                              \ 'M:case objects;' .
                              \ 't:traits;' .
                              \ 'T:types;' .
                              \ 'f:functions;' .
                              \ 'V:values;' .
                              \ 'v:variables'
    " }

    " coffeetags {
      if executable('coffeetags')
        let g:tagbar_type_coffee = {
              \ 'ctagsbin' : 'coffeetags',
              \ 'ctagsargs' : '',
              \ 'kinds' : [
              \ 'f:functions',
              \ 'o:object',
              \ ],
              \ 'sro' : ".",
              \ 'kind2scope' : {
              \ 'f' : 'object',
              \ 'o' : 'object',
              \ }
              \ }
      endif
    " }

    " tagbar {
      nmap <F3> :TagbarToggle<CR>
    " }

    " lushtags {
      if executable('lushtags')
          let g:tagbar_type_haskell = {
              \ 'ctagsbin' : 'lushtags',
              \ 'ctagsargs' : '--ignore-parse-error --',
              \ 'kinds' : [
                  \ 'm:module:0',
                  \ 'e:exports:1',
                  \ 'i:imports:1',
                  \ 't:declarations:0',
                  \ 'd:declarations:1',
                  \ 'n:declarations:1',
                  \ 'f:functions:0',
                  \ 'c:constructors:0'
              \ ],
              \ 'sro' : '.',
              \ 'kind2scope' : {
                  \ 'd' : 'data',
                  \ 'n' : 'newtype',
                  \ 'c' : 'constructor',
                  \ 't' : 'type'
              \ },
              \ 'scope2kind' : {
                  \ 'data' : 'd',
                  \ 'newtype' : 'n',
                  \ 'constructor' : 'c',
                  \ 'type' : 't'
              \ }
          \ }
      endif
    " }

    " syntastic {

    " }

    " javascript {
    let g:javascript_conceal = 0
    "}

    " NERDCommenter {
      let g:NERDCustomDelimiters = {
          \ 'c': { 'left': '/**','right': '*/', 'leftAlt': '//' },
          \ 'javascript': { 'left': '//', 'leftAlt': '/**', 'rightAlt': '*/' },
          \ 'javascript.jquery': { 'left': '//', 'leftAlt': '/**', 'rightAlt': '*/' },
      \ }
    " }

" }

" Remove Bell {
  set noerrorbells visualbell t_vb=
  if has('autocmd')
    autocmd GUIEnter * set visualbell t_vb=
  endif
" }

" GUI Settings {
  "GVIM
  if has('gui_running')
    set guioptions-=T
    set guioptions+=LlRrbh
    set guioptions-=LlRrbh
    set lines=40
    if has('gui_gtk2')
      "set guifont=Andale\ Mono\ Regular\ 16,Menlo\ Regular\ 15,Consolas\ Regular\ 16,Courier\ New\ Regular\ 18
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 12
    else
      set guifont=Andale\ Mono\ Regular:h16,Menlo\ Regular:h15,Consolas\ Regular:h16,Courier\ New\ Regular:h18
    endif
    if has('gui_macvim')
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h16
      set transparency=0
    endif
  else
    set guifont=DejaVu\ Sans\ Mono\ for\ Powerline:h12
    set clipboard=unnamed
    if &term == 'xterm' || &term == 'screen'
      set t_Co=256
    endif
  endif

" }

" Functions {
  " function: InitializeDirectories {
    function! InitializeDirectories()
        let separator = "."
        let parent = $HOME
        let prefix = '.vim'
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory' }

        if has('persistent_undo')
            let dir_list['undo'] = 'undodir'
        endif

        for [dirname, settingname] in items(dir_list)
            let directory = parent . '/' . prefix . dirname . "/"
            if exists("*mkdir")
                if !isdirectory(directory)
                    call mkdir(directory)
                endif
            endif
            if !isdirectory(directory)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . directory
            else
                let directory = substitute(directory, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . directory
            endif
        endfor
    endfunction
    call InitializeDirectories()
  " }

  " function: Strip whitespace {
    function! StripTrailingWhitespace()
      " Preparation: save last search, and cursor position.
      let _s=@/
      let l = line(".")
      let c = col(".")
      " Do the business:
      %s/\s\+$//e
      " Clean up: restore previous search history, and cursor position
      let @/=_s
      call cursor(l, c)
    endfunction
  " }

  " function: Execute Command {
    function! RCmd(cmd)
      :silent! exe '!echo "cd ' . getcwd() . ' && ' . a:cmd . '" > /tmp/cmds'
      :redraw!
    endfunction
  " }
  "
  function! RCmd(cmd)
    :silent! exe '!echo "cd `pwd` && ' . a:cmd . '" > /tmp/cmds'
    :redraw!
  endfunction

  function! FindGitDirOrRoot()
    let curdir = expand('%:p:h')
    let gitdir = finddir('.git', curdir . ';')
    if gitdir != ''
      return substitute(gitdir, '\/\.git$', '', '')
    else
      return '/'
    endif
  endfunction
" }

" Setup Local gvimrc {
  if filereadable(expand(".gvimrc.local"))
    source .gvimrc.local
  endif
" }

